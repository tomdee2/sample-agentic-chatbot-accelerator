# ------------------------------------------------------------------------ #
# Copyright 2026 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# SPDX-License-Identifier: MIT-0
# ------------------------------------------------------------------------ #
from __future__ import annotations

from enum import Enum
from typing import Optional, Union

from pydantic import BaseModel, model_validator


class EStreamEvent(Enum):
    """Defines the possible stream event types for streaming operations.

    Attributes:
        STREAM_COMPLETE: Event indicating that the stream has completed
        THINKING_TOKEN: Event indicating that the model is processing/thinking
        FINAL_RESPONSE_TOKEN: Event indicating the final response has been generated
    """

    STREAM_COMPLETE = (
        "STREAM_COMPLETE"  # nosec B105 - not a password, stream event type
    )
    THINKING_TOKEN = "THINKING_TOKEN"  # nosec B105 - not a password, stream event type
    FINAL_RESPONSE_TOKEN = (
        "FINAL_RESPONSE_TOKEN"  # nosec B105 - not a password, stream event type
    )


class EConversationManagerType(str, Enum):
    """Defines the possible conversation manager types for handling chat history.

    Attributes:
        NULL: No conversation management - each message is handled independently
        SLIDING_WINDOW: Maintains a sliding window of recent messages for context
        SUMMARIZING: Summarizes older messages to maintain context while managing memory
    """

    NULL = "null"
    SLIDING_WINDOW = "sliding_window"
    SUMMARIZING = "summarizing"


class StrandToken(BaseModel):
    """Represents a token generated by Strands Agents with associated event flag.

    Attributes:
        value (str): The text value of the token
        flag (EStreamEvent): The event flag associated with this token.
            See `EStreamEvent` for valid options.
    """

    value: str
    flag: EStreamEvent


class InferenceConfig(BaseModel):
    """Configuration for model inference parameters.

    Attributes:
        maxTokens (int): Maximum number of tokens to generate in the response
        temperature (float): Controls randomness in response generation. Higher values (e.g. 1.0) make output more random,
            lower values (e.g. 0.1) make it more focused and deterministic
        stopSequences (Optional[List[str]]): List of sequences that will stop text generation when encountered. Default None
    """

    maxTokens: int
    temperature: float
    stopSequences: Optional[list[str]] = None


class ModelConfiguration(BaseModel):
    """Configuration class for model inference settings.

    Attributes:
        modelId (str): Identifier for the model to be used
        parameters (InferenceConfig): Configuration parameters for model inference
    """

    modelId: str
    parameters: InferenceConfig


class AgentConfiguration(BaseModel):
    modelInferenceParameters: ModelConfiguration
    instructions: str
    tools: list[str]
    toolParameters: dict[str, dict]
    mcpServers: list[str]
    conversationManager: EConversationManagerType = (
        EConversationManagerType.SLIDING_WINDOW
    )

    @model_validator(mode="after")
    def validate_tool_parameters(self):
        """Validates that tool parameters match the defined tools.

        Checks that:
        - All tool parameter keys correspond to defined tools
        - Sub-agent tools have required agentName and agentVersion parameters

        Returns:
            AgentConfiguration: The validated configuration object

        Raises:
            ValueError: If validation fails due to missing or invalid parameters
        """
        tool_names = {tool_name for tool_name in self.tools}
        invalid_keys = set(self.toolParameters.keys()) - tool_names
        if invalid_keys:
            raise ValueError(f"toolParameters keys {invalid_keys} not found in tools")

        return self


class Token(BaseModel):
    position: int
    value: str


class ChatbotAction(Enum):
    """
    Enum class defining the possible actions that can be taken by the chatbot.

    Attributes:
        HEARTBEAT: Represents a heartbeat action to check if the chatbot is active
        RUN: Represents the main execution action of the chatbot
        ON_NEW_LLM_TOKEN: Represents a new token received from the language model that belongs to the final answer
        FINAL_RESPONSE: Represents the final response action from the chatbot
    """

    HEARTBEAT = "heartbeat"
    RUN = "run"
    ON_NEW_LLM_TOKEN = (
        "on_new_llm_token"  # nosec B105 - not a password, chatbot action type
    )
    FINAL_RESPONSE = "final_response"


class ESearchType(Enum):
    """Defines the search types available for knowledge base retrieval.

    Attributes:
        HYBRID: Combined semantic and keyword-based search approach
        SEMANTIC: Pure semantic search using embeddings and vector similarity
    """

    HYBRID = "HYBRID"
    SEMANTIC = "SEMANTIC"


class MetadataAttribute(BaseModel):
    """Defines metadata attributes for knowledge base entries.

    This class represents the structure of metadata attributes that can be associated with
    knowledge base entries, specifying their description, key name, and data type.

    Attributes:
        description (str): A description of what this metadata attribute represents
        key (str): The key name used to identify this metadata attribute
        type (str): The data type of this metadata attribute. Should be one of the types
            defined in MetadataAttributeTypes enum.

    Examples:
        >>> attr = MetadataAttribute(
        ...     description="Document author name",
        ...     key="author",
        ...     type="STRING"
        ... )
    """

    description: str
    key: str
    type: str


class ImplicitFilterConfiguration(BaseModel):
    """Configuration for implicit filtering of knowledge base results.

    This class defines the configuration for implicit filtering of knowledge base query results
    based on metadata attributes and a model used for filtering.

    Attributes:
        metadataAttributes (List[MetadataAttribute]): List of metadata attributes to use for filtering.
            See MetadataAttribute class for details on attribute structure.
        modelArn (str): The Amazon Resource Name (ARN) of the model to use for implicit filtering.

    Examples:
        >>> config = ImplicitFilterConfiguration(
        ...     metadataAttributes=[MetadataAttribute(description="doc type", key="type", type="STRING")],
        ...     modelArn="arn:aws:bedrock:us-west-2:123456789012:model/my-filter-model"
        ... )
    """

    metadataAttributes: list[MetadataAttribute]
    modelArn: str


class RerankingFieldName(BaseModel):
    """Represents a field name used in reranking configuration.

    Attributes:
        fieldName (str): The name of the field to be included/excluded in reranking
    """

    fieldName: str


class RerankingSelectiveModeConfiguration(BaseModel):
    """Configuration for selective mode reranking field inclusion/exclusion.

    This class defines which specific fields should be included or excluded when
    reranking is performed in selective mode.

    Attributes:
        fieldsToExclude (List[RerankingFieldName]): List of field names to exclude from reranking
        fieldsToInclude (List[RerankingFieldName]): List of field names to include in reranking

    Examples:
        >>> config = RerankingSelectiveModeConfiguration(
        ...     fieldsToExclude=[{"fieldName": "timestamp"}],
        ...     fieldsToInclude=[{"fieldName": "title"}, {"fieldName": "content"}]
        ... )
    """

    fieldsToExclude: list[RerankingFieldName]
    fieldsToInclude: list[RerankingFieldName]


class ERerankingMetadataSelectionMode(Enum):
    """Defines the selection modes for reranking metadata fields.

    This enum specifies which metadata fields should be taken into account during the reranking process.

    Attributes:
        SELECTIVE: Only include/exclude specific metadata fields defined in the configuration
        ALL: Include all available metadata fields in reranking
    """

    SELECTIVE = "SELECTIVE"
    ALL = "ALL"


class RerankingMetadataConfiguration(BaseModel):
    """Configuration for metadata handling during reranking.

    This class defines how metadata fields should be handled during the reranking process,
    including which selection mode to use and specific field configurations.

    Attributes:
        selectionMode (ERerankingMetadataSelectionMode): The mode for selecting which metadata
            fields to include in reranking. See ERerankingMetadataSelectionMode enum for options.
        selectiveModeConfiguration (Optional[RerankingSelectiveModeConfiguration]): Configuration for
            selective mode, specifying which fields to include/exclude. Only used when
            selectionMode is SELECTIVE. Optional field.

    Examples:
        >>> config = RerankingMetadataConfiguration(
        ...     selectionMode=ERerankingMetadataSelectionMode.SELECTIVE,
        ...     selectiveModeConfiguration=RerankingSelectiveModeConfiguration(
        ...         fieldsToInclude=[RerankingFieldName(fieldName="title")],
        ...         fieldsToExclude=[RerankingFieldName(fieldName="timestamp")]
        ...     )
        ... )
    """

    selectionMode: ERerankingMetadataSelectionMode
    selectiveModeConfiguration: Optional[RerankingSelectiveModeConfiguration] = None


class RerankingModelConfiguration(BaseModel):
    """Configuration for reranking model used to reorder knowledge base results.

    This class defines the configuration for a reranking model that can be used to
    reorder and optimize the relevance of knowledge base query results.

    Attributes:
        modelArn (str): The Amazon Resource Name (ARN) of the reranking model to use.
            This should be a valid ARN pointing to a model that supports reranking.

    Examples:
        >>> config = RerankingModelConfiguration(
        ...     modelArn="arn:aws:bedrock:us-west-2:123456789012:model/my-reranking-model"
        ... )

    Notes:
        - Ignoring `additionalModelRequestFields` because we don't plan, unless proven useful, to use custom model parameters specific to the language model being used.
    """

    modelArn: str


class BedrockRerankingConfiguration(BaseModel):
    """Configuration for Bedrock reranking functionality.

    This class defines the configuration parameters for reranking results using Bedrock,
    including metadata handling, model configuration, and number of results to rerank.

    Attributes:
        modelConfiguration (RerankingModelConfiguration): Configuration for the reranking model to be used.
            See RerankingModelConfiguration for details.
        metadataConfiguration (Optional[RerankingMetadataConfiguration]): Optional configuration for how metadata
            should be handled during reranking. See RerankingMetadataConfiguration for details.
        numberOfResults (Optional[int]): Number of results to rerank. If not specified, all retrieved results will be reranked.

    Examples:
        >>> config = BedrockRerankingConfiguration(
        ...     modelConfiguration=RerankingModelConfiguration(
        ...         modelArn="arn:aws:bedrock:us-west-2:123456789012:model/my-reranking-model"
        ...     ),
        ...     metadataConfiguration=RerankingMetadataConfiguration(
        ...         selectionMode=ERerankingMetadataSelectionMode.SELECTIVE
        ...     ),
        ...     numberOfResults=10
        ... )
    """

    modelConfiguration: RerankingModelConfiguration
    metadataConfiguration: Optional[RerankingMetadataConfiguration] = None
    numberOfResults: Optional[int] = None


class RerankingConfiguration(BaseModel):
    """Configuration for reranking functionality in knowledge base queries.

    This class defines the configuration for reranking search results, including the
    Bedrock reranking configuration and reranking type.

    Attributes:
        bedrockRerankingConfiguration (BedrockRerankingConfiguration): Configuration for
            Bedrock reranking functionality. See BedrockRerankingConfiguration for details.
        type (str): The type of reranking to use. Defaults to "BEDROCK_RERANKING_MODEL".

    Examples:
        >>> config = RerankingConfiguration(
        ...     bedrockRerankingConfiguration=bedrock_config,
        ...     type="BEDROCK_RERANKING_MODEL"
        ... )
    """

    bedrockRerankingConfiguration: BedrockRerankingConfiguration
    type: str = "BEDROCK_RERANKING_MODEL"


class KnowledgeBaseRetrievalConfiguration(BaseModel):
    """Configuration for retrieving results from a knowledge base.

    This class defines parameters for controlling how results are retrieved from the knowledge base,
    including number of results, filtering, search type and reranking options.

    Attributes:
        numberOfResults (int): The number of results to retrieve from the knowledge base
        filter (Optional[dict]): Optional dictionary specifying filter criteria on the metadata for the search.
            See https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html
            and boto3 documentation https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/bedrock-agent-runtime/client/retrieve_and_generate.html
        overrideSearchType (Optional[SearchType]): Optional override for the search type (SEMANTIC or HYBRID).
            If not specified, uses the knowledge base default search type.
        implicitFilterConfiguration (Optional[ImplicitFilterConfiguration]): Optional configuration for
            implicit filtering of results based on metadata. See ImplicitFilterConfiguration for details.
        rerankingConfiguration (Optional[RerankingConfiguration]): Optional configuration for reranking
            the retrieved results. See RerankingConfiguration for details.

    Examples:
        >>> config = KnowledgeBaseRetrievalConfiguration(
        ...     numberOfResults=10,
        ...     overrideSearchType=SearchType.SEMANTIC,
        ...     filter={
        ...         "andAll": [
        ...             { "equals": { "key": "genre", "value": "strategy" } },
        ...             { "greaterThanOrEquals": { "key": "year", "value": 2023 } }
        ...         ]
        ...     }
        ... )
    """

    numberOfResults: int
    filter: Optional[dict] = None
    overrideSearchType: Optional[ESearchType] = None
    implicitFilterConfiguration: Optional[ImplicitFilterConfiguration] = None
    rerankingConfiguration: Optional[RerankingConfiguration] = None


class RetrievalConfiguration(BaseModel):
    """Configuration for vector search operations in knowledge base queries.

    This class wraps the knowledge base retrieval configuration specifically for vector search operations,
    providing settings for controlling how vector-based similarity searches are performed.

    Attributes:
        vectorSearchConfiguration (KnowledgeBaseRetrievalConfiguration): Configuration parameters
            for retrieving results using vector search, including number of results, filtering,
            search type and reranking options. See KnowledgeBaseRetrievalConfiguration for details.

    Examples:
        >>> config = VectorSearchConfig(
        ...     vectorSearchConfiguration=KnowledgeBaseRetrievalConfiguration(
        ...         numberOfResults=10,
        ...         overrideSearchType=SearchType.SEMANTIC
        ...     )
        ... )
    """

    vectorSearchConfiguration: KnowledgeBaseRetrievalConfiguration


class EContentType(Enum):
    """Defines the content types supported in knowledge base references.

    Attributes:
        TEXT: Content type for text-based references
        IMAGE: Content type for image-based references
        ROW: Content type for row/record-based references from databases
    """

    TEXT = "TEXT"
    IMAGE = "IMAGE"
    ROW = "ROW"


class ERowType(Enum):
    """Data type of the column value"""

    BLOB = "BLOB"
    BOOLEAN = "BOOLEAN"
    DOUBLE = "DOUBLE"
    NULL = "NULL"
    LONG = "LONG"
    STRING = "STRING"


class RowContent(BaseModel):
    """Represents a single row/column value from a database result.

    Attributes:
        columnName (str): The name of the database column
        columnValue (str): The value stored in this column
        type (ERowType): The data type of the column value. See ERowType enum for valid options.

    Examples:
        >>> row = RowContent(
        ...     columnName="user_id",
        ...     columnValue="12345",
        ...     type=ERowType.STRING
        ... )
    """

    columnName: str
    columnValue: str
    type: ERowType


class ReferenceContent(BaseModel):
    """Represents content from a knowledge base reference with type-specific validation.

    This class handles different types of reference content (text, row, or image) and ensures
    that the appropriate content field is populated based on the specified type.

    Attributes:
        byteContent (Optional[str]): Base64 encoded image content, required when type is IMAGE
        row (Optional[RowContent]): Row/record content from database, required when type is ROW
        text (Optional[str]): Text content, required when type is TEXT
        type (EContentType): The type of content this reference contains

    Raises:
        ValueError: If the required content field for the specified type is missing
        AssertionError: If an unhandled content type is specified

    Examples:
        >>> # Text content
        >>> ref = ReferenceContent(
        ...     text="Sample text content",
        ...     type=EContentType.TEXT
        ... )

        >>> # Row content
        >>> ref = ReferenceContent(
        ...     row=RowContent(...),
        ...     type=EContentType.ROW
        ... )

        >>> # Image content
        >>> ref = ReferenceContent(
        ...     byteContent="base64_encoded_image",
        ...     type=EContentType.IMAGE
        ... )
    """

    __nb_chars__ = 100

    byteContent: Optional[str] = None
    row: Optional[RowContent] = None
    text: Optional[str] = None
    type: EContentType

    @model_validator(mode="after")
    def validate_content_based_on_type(self) -> "ReferenceContent":
        if self.type == EContentType.TEXT:
            if not self.text:
                raise ValueError("Text content is required when type is TEXT")

        elif self.type == EContentType.ROW:
            if not self.row:
                raise ValueError("Row content is required when type is ROW")

        elif self.type == EContentType.IMAGE:
            if not self.byteContent:
                raise ValueError("Byte content is required when type is IMAGE")
        else:
            raise AssertionError(f"Add implementation for enum option {self.type}")

        return self

    def get_content(self) -> str:
        if self.type == EContentType.TEXT and self.text:
            return self.text
        else:
            # TODO modify the following implementation if something other than text is needed
            raise ValueError(self.type.value, "todo implement this")

    def __eq__(self, other: ReferenceContent) -> bool:
        return (self.type == other.type) and (
            self.get_content()[: self.__nb_chars__]
            == other.get_content()[: self.__nb_chars__]
        )

    def __hash__(self) -> int:
        return hash((self.type.value, self.get_content()[: self.__nb_chars__]))


class ELocationType(Enum):
    """Defines the supported location types for knowledge base references.

    This enum specifies the different types of locations where knowledge base content can be stored
    and retrieved from.

    Attributes:
        S3: Amazon S3 storage location
        WEB: Web-based location accessible via URL
        CONFLUENCE: Atlassian Confluence location
        SALESFORCE: Salesforce location
        SHAREPOINT: Microsoft SharePoint location
        CUSTOM: Custom location type
        KENDRA: Amazon Kendra index location
        SQL: SQL database location

    Examples:
        >>> location_type = ELocationType.S3
        >>> location_type = ELocationType.CONFLUENCE
    """

    S3 = "S3"
    WEB = "WEB"
    CONFLUENCE = "CONFLUENCE"
    SALESFORCE = "SALESFORCE"
    SHAREPOINT = "SHAREPOINT"
    CUSTOM = "CUSTOM"
    KENDRA = "KENDRA"
    SQL = "SQL"


class ReferenceLocation(BaseModel):
    """Represents the location of a knowledge base reference with type-specific validation.

    This class handles different types of reference locations (S3, Confluence, etc.) and ensures
    that the appropriate location field is populated based on the specified type.

    Attributes:
        confluenceLocation (Optional[dict]): Location details for Confluence references
        customDocumentLocation (Optional[dict]): Location details for custom document references
        kendraDocumentLocation (Optional[dict]): Location details for Kendra index references
        s3Location (Optional[dict]): Location details for S3 references
        sharePointLocation (Optional[dict]): Location details for SharePoint references
        sqlLocation (Optional[dict]): Location details for SQL database references
        type (ELocationType): The type of location this reference uses

    Raises:
        ValueError: If the required location field for the specified type is missing
        AssertionError: If an unhandled location type is specified

    Examples:
        >>> # S3 location
        >>> loc = ReferenceLocation(
        ...     s3Location={"uri": "s3://XXXX/path/to/file.pdf"},
        ...     type=ELocationType.S3
        ... )

        >>> # Confluence location
        >>> loc = ReferenceLocation(
        ...     confluenceLocation={"url": "https://confluence.example.com/display/SPACEKEY/Page+Title"},
        ...     type=ELocationType.CONFLUENCE
        ... )
    """

    confluenceLocation: Optional[dict] = None
    customDocumentLocation: Optional[dict] = None
    kendraDocumentLocation: Optional[dict] = None
    s3Location: Optional[dict] = None
    sharePointLocation: Optional[dict] = None
    sqlLocation: Optional[dict] = None
    webLocation: Optional[dict] = None

    type: ELocationType

    @model_validator(mode="after")
    def validate_content_based_on_type(self) -> "ReferenceLocation":
        if self.type == ELocationType.S3:
            if not self.s3Location:
                raise ValueError("s3Location is required when type is S3")
        elif self.type == ELocationType.CONFLUENCE:
            if not self.confluenceLocation:
                raise ValueError(
                    "confluenceLocation is required when type is CONFLUENCE"
                )
        elif self.type == ELocationType.CUSTOM:
            if not self.customDocumentLocation:
                raise ValueError(
                    "customDocumentLocation is required when type is CUSTOM"
                )
        elif self.type == ELocationType.KENDRA:
            if not self.kendraDocumentLocation:
                raise ValueError(
                    "kendraDocumentLocation is required when type is KENDRA"
                )
        elif self.type == ELocationType.SHAREPOINT:
            if not self.sharePointLocation:
                raise ValueError(
                    "sharePointLocation is required when type is SHAREPOINT"
                )
        elif self.type == ELocationType.SQL:
            if not self.sqlLocation:
                raise ValueError("sqlLocation is required when type is SQL")
        elif self.type == ELocationType.WEB:
            if not self.webLocation:
                raise ValueError("webLocation is required when type is WEB")
        else:
            raise AssertionError(f"Add implementation for enum option {self.type}")

        return self

    def get_id(self) -> str:
        """Gets the unique identifier for this reference location.

        Returns:
            str: The unique identifier string for this location. For S3 locations, this is the S3 URI.

        Raises:
            InvalidReference: If the location type is not S3 (not yet implemented), or if the S3 URI is invalid.

        Examples:
            >>> loc = ReferenceLocation(s3Location={"uri": "s3://bucket/key"}, type=ELocationType.S3)
            >>> loc.get_id()
            's3://bucket/key'
        """
        if self.type == ELocationType.S3 and self.s3Location:
            ref_id: str = self.s3Location.get("uri", "null")
            if not ref_id.startswith("s3://"):
                raise ValueError(ELocationType.S3.value, ref_id)
        elif self.type == ELocationType.WEB and self.webLocation:
            ref_id: str = self.webLocation.get("url", "null")
            if not (ref_id.startswith("http://") or ref_id.startswith("https://")):
                raise ValueError(ELocationType.WEB.value, ref_id)
        else:
            # TODO - modify this implementation if using other data sources than S3
            raise ValueError(self.type.value, "todo add implementation")
        return ref_id

    def __eq__(self, other: ReferenceLocation) -> bool:
        out = self.type == other.type

        if out:
            out = self.get_id() == other.get_id()
        return out

    def __hash__(self) -> int:
        ref_id = self.get_id()
        return hash((self.type.value, ref_id))


class RetrievedReference(BaseModel):
    """Represents a reference retrieved from a knowledge base with its content, location and metadata.

    This class encapsulates a complete reference from a knowledge base, including the actual content,
    the location where it was retrieved from, and any associated metadata.

    Attributes:
        content (ReferenceContent): The content of the reference, which can be text, image or row data.
            See ReferenceContent class for details.
        location (ReferenceLocation): The location information for where this reference was retrieved from.
            See ReferenceLocation class for details.
        metadata (dict[str, Union[dict, List, int, float, str, bool, None]]): A dictionary of metadata
            associated with this reference. The values can be of various types including nested
            dictionaries, lists, numbers, strings, booleans or null values.

    Examples:
        >>> reference = RetrievedReference(
        ...     content=ReferenceContent(text="Sample content", type=EContentType.TEXT),
        ...     location=ReferenceLocation(
        ...         s3Location={"uri": "s3://bucket/document.pdf"},
        ...         type=ELocationType.S3
        ...     ),
        ...     metadata={
        ...         "author": "John Doe",
        ...         "created_date": "2024-01-01",
        ...         "tags": ["document", "sample"]
        ...     }
        ... )
    """

    content: ReferenceContent
    location: ReferenceLocation
    metadata: dict[str, Union[dict, list, int, float, str, bool, None]]

    def get_page_number(self) -> Optional[int]:
        """Gets the page number from the reference metadata.

        Extracts the page number from the reference metadata using the 'x-amz-bedrock-kb-document-page-number' key.
        If the page number exists and is a float, converts it to an integer.

        Returns:
            Optional[int]: The page number as an integer if it exists in the metadata, None otherwise.
        """
        page_number = self.metadata.get("x-amz-bedrock-kb-document-page-number")
        if page_number and isinstance(page_number, float):
            page_number = int(page_number)
        return page_number  # type: ignore

    def __eq__(self, other: RetrievedReference):
        is_same_location = self.location == other.location
        is_same_content = self.content == other.content
        return is_same_location and is_same_content

    def __hash__(self):
        page_nb = self.get_page_number()
        if not page_nb:
            page_nb = 0
        return hash((self.content.get_content()[:20], self.location.get_id(), page_nb))


class Interval(BaseModel):
    """Represents an interval with start and end positions, typically used
    to identify spans of text or other sequential data.

    Attributes:
        start (int): The starting position of the interval (inclusive)
        end (int): The ending position of the interval (exclusive)

    Examples:
        >>> interval = Interval(start=0, end=10)
    """

    start: int
    end: int


class TextResponsePartElement(BaseModel):
    """Represents a part of a text response with its corresponding span interval.

    This class defines a text segment and its position within a larger text response,
    using an interval to mark its start and end positions.

    Attributes:
        span (Interval): The interval marking the start and end positions of this text part
        text (str): The actual text content for this response part

    Examples:
        >>> element = TextResponsePartElement(
        ...     span=Interval(start=0, end=10),
        ...     text="Hello world"
        ... )
    """

    span: Interval
    text: str


class TextResponsePart(BaseModel):
    """Represents a part of a text response in a knowledge base query result.

    Attributes:
        textResponsePart (TextResponsePartElement): The text response part element containing
            the text content and its span interval. See TextResponsePartElement for details.

    Examples:
        >>> response_part = TextResponsePart(
        ...     textResponsePart=TextResponsePartElement(
        ...         span=Interval(start=0, end=10),
        ...         text="Hello world"
        ...     )
        ... )
    """

    textResponsePart: TextResponsePartElement


class Citation(BaseModel):
    """Represents a citation linking retrieved references to generated response parts.

    This class associates retrieved references from a knowledge base with the specific part
    of the generated response that used those references.

    Attributes:
        retrievedReferences (List[RetrievedReference]): List of references retrieved from the
            knowledge base that were used as sources. See RetrievedReference class for details.
        generatedResponsePart (Optional[TextResponsePart]): The specific part of the generated
            response that was derived from these references. See TextResponsePart class for details.

    Examples:
        >>> citation = Citation(
        ...     retrievedReferences=[reference1, reference2],
        ...     generatedResponsePart=TextResponsePart(...)
        ... )
    """

    retrievedReferences: list[RetrievedReference]
    generatedResponsePart: Optional[TextResponsePart] = None


class TextOutput(BaseModel):
    """Output format for generated answer

    Attributes:
        text (str): The generated text

    Examples:
        >>> output = Output(text="The capital of France is Paris.")
    """

    text: str


class EGuardrailAction(Enum):
    """Defines the possible guardrail actions taken during response generation.

    Attributes:
        INTERVENED: Indicates that guardrails were triggered and modified the response
        NONE: Indicates that no guardrail actions were taken
    """

    INTERVENED = "INTERVENED"
    NONE = "NONE"


class GenerateResponse(BaseModel):
    """Response from a non-streaming generate operation containing citations and output.

    Attributes:
        citations (List[Citation]): List of citations linking source references to generated response parts.
            See Citation class for details on citation structure.
        output (TextOutput): The generated text output.
            See TextOutput class for details.
        sessionId (str): Unique identifier for the session this response was generated in.
        guardrailAction (Optional[EGuardrailAction]): Indicates if any guardrail actions were applied
            to modify the response. See EGuardrailAction enum for possible values.

    Examples:
        >>> response = KnowledgeBaseGenerateResponse(
        ...     citations=[Citation(...)],
        ...     output=TextOutput(text="Generated answer"),
        ...     sessionId="session-123",
        ...     guardrailAction=EGuardrailAction.NONE
        ... )
    """

    citations: list[Citation]
    output: TextOutput
    sessionId: str
    guardrailAction: Optional[EGuardrailAction] = None


class KnowledgeBaseGenerateResponse(GenerateResponse):
    """Response from a knowledge base generate operation containing citations and output.

    This class represents the complete response from a knowledge base query and generation operation,
    including the generated output, citations to source references, session tracking, and any
    guardrail actions that were applied.

    Attributes:
        citations (List[Citation]): List of citations linking source references to generated response parts.
            See Citation class for details on citation structure.
        output (TextOutput): The generated text output from the knowledge base.
            See TextOutput class for details.
        sessionId (str): Unique identifier for the session this response was generated in.
        guardrailAction (Optional[EGuardrailAction]): Indicates if any guardrail actions were applied
            to modify the response. See EGuardrailAction enum for possible values.

    Examples:
        >>> response = KnowledgeBaseGenerateResponse(
        ...     citations=[Citation(...)],
        ...     output=TextOutput(text="Generated answer"),
        ...     sessionId="session-123",
        ...     guardrailAction=EGuardrailAction.NONE
        ... )
    """

    citations: list[Citation]
    output: TextOutput
    sessionId: str
    guardrailAction: Optional[EGuardrailAction] = None
