# ---------------------------------------------------------------------------- #
# Copyright 2026 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# SPDX-License-Identifier: Apache-2.0
# ---------------------------------------------------------------------------- #
# TODO: Remove code duplication - consider moving shared code to a common module
from __future__ import annotations

from typing import TYPE_CHECKING

from strands.hooks import AfterToolCallEvent, BeforeToolCallEvent

from .constants import RETRIEVE_FROM_KB_PREFIX
from .types import Citation, RetrievedReference

if TYPE_CHECKING:
    from logging import Logger


class AgentCallbacks:
    """Class to handle callbacks for swarm agent operations.

    This class provides callback handlers for various swarm operations including
    tool invocations and knowledge base retrievals. It manages metadata collection
    and logging during swarm execution.

    Attributes:
        _metadata (dict): Dictionary storing metadata generated by tools, e.g. Knowledge base references.
        _logger (Logger): Logger instance for recording agent operations and tool usage.
    """

    def __init__(self, logger: Logger) -> None:
        self._metadata = dict()
        self._logger = logger

    @property
    def metadata(self) -> dict:
        return self._metadata

    def reset_metadata(self) -> None:
        self._metadata = dict()

    def log_tool_entries(self, event: BeforeToolCallEvent) -> None:
        """Logs information about tool invocation before it occurs.

        Args:
            event (BeforeToolCallEvent): Event containing metadata about the tool
                that will be invoked.

        Returns:
            None
        """
        self._logger.info(
            "Agent is going to call a tool",
            extra={"toolInfo": event.tool_use},
        )

    def log_tool_results(self, event: AfterToolCallEvent) -> None:
        if event.selected_tool:
            self._logger.info(
                "The tool returned a response",
                extra={
                    "payload": {
                        "toolName": event.selected_tool.tool_name,
                        "result": event.result,
                    }
                },
            )

    def retrieve_from_kb_callback(self, event: AfterToolCallEvent) -> None:
        """Callback handler for knowledge base retrieval operations.

        Processes retrieval results from knowledge base queries, formats citations,
        and updates metadata with references.

        Args:
            event (AfterToolCallEvent): Event containing tool invocation results
                and metadata.

        Returns:
            None
        """
        if event.selected_tool and event.selected_tool.tool_name.startswith(
            RETRIEVE_FROM_KB_PREFIX
        ):
            sources = event.result.get("content", [{}])[0].get("json", {}).get("retrievalResults", [])  # type: ignore
            if not sources:
                # No sources found --> return
                return

            citations = Citation(
                retrievedReferences=[
                    RetrievedReference.model_validate(s) for s in sources
                ]
            )
            formatter = FormatCitations([citations])

            # Get existing unique references (RetrievedReference objects)
            existing_unique_refs = self._metadata.get("_unique_references", [])

            # Combine with new ones using set to deduplicate (leveraging __hash__ and __eq__)
            all_unique_refs = list(
                set(existing_unique_refs + list(formatter._unique_references))
            )

            # Store the unique references for future deduplication
            self._metadata["_unique_references"] = all_unique_refs

            # Format references with sequential IDs
            references = []
            for ref_id, ref in enumerate(all_unique_refs):
                references.append(
                    {
                        "referenceId": str(ref_id + 1),
                        "uri": ref.location.get_id(),
                        "pageNumber": str(ref.get_page_number()),
                        "content": ref.content.get_content(),
                        "documentTitle": (
                            ".".join(ref.metadata["documentName"].split(".")[:-1])  # type: ignore
                            if "documentName" in ref.metadata
                            else ref.location.get_id()
                        ),
                    }
                )

            self._metadata["references"] = references


class FormatCitations:
    """A class for formatting citations and references from knowledge base responses.

    This class processes citation information from knowledge base responses and formats them
    into standardized reference and citation objects for display or further processing.

    Attributes:
        _citations (Sequence[Citation]): The sequence of Citation objects to process
        _unique_references (Sequence[RetrievedReference]): Deduplicated list of references

    Args:
        citations (Sequence[Citation]): The sequence of Citation objects to format
    """

    def __init__(self, citations: list[Citation]):
        self._citations = citations
        self._unique_references: list[
            RetrievedReference
        ] = self._get_unique_references()

    def _get_unique_references(self):
        unique_references = set()
        for cit in self._citations:
            retrieved_reference = cit.retrievedReferences
            for ref in retrieved_reference:
                unique_references.add(ref)
        return list(unique_references)

    def get_references(self) -> list[dict]:
        """Get formatted references from the unique references.

        Returns:
            Sequence[Dict]: A list of dictionaries containing formatted reference information.
            Each dictionary has the following keys:
                - referenceId (str): Unique identifier for the reference
                - uri (str): URI location of the referenced document
                - pageNumber (str): Page number where the reference appears
                - content (str): The referenced content
                - documentTitle (str): Title of the source document
        """
        references = []
        for ref_id, ref in enumerate(self._unique_references):
            references.append(
                {
                    "referenceId": str(ref_id + 1),
                    "uri": ref.location.get_id(),
                    "pageNumber": str(ref.get_page_number()),
                    "content": ref.content.get_content(),
                    "documentTitle": (
                        ".".join(ref.metadata["documentName"].split(".")[:-1])  # type: ignore
                        if "documentName" in ref.metadata
                        else ref.location.get_id()
                    ),
                }
            )
        return references

    def get_formatted_citations(self) -> list[dict]:
        """Get formatted citations with reference IDs and locations.

        Returns:
            Sequence[Dict]: A list of dictionaries containing formatted citation information.
            Each dictionary has the following keys:
                - referenceId (int): ID of the reference (1-based index)
                - location (int): End position of the citation in the response text

        Note:
            Citations are sorted by referenceId before being returned.
        """
        formatted_citations = []
        for cit in self._citations:
            if not cit.generatedResponsePart:
                continue
            response_part = cit.generatedResponsePart.textResponsePart
            for ref in cit.retrievedReferences:
                formatted_citations.append(
                    {
                        "referenceId": self._unique_references.index(ref) + 1,
                        "location": response_part.span.end,
                    }
                )
        return sorted(
            formatted_citations, key=lambda x: (x["location"], x["referenceId"])
        )
